var, let, const, 셋 다 선언 명령어이다.

<br/>
<br/>

## 변수 생성 과정 (3단계)

1. 선언 단계
    1. `var`, `let`, `const` 중 필요한 선언 키워드를 통해 이뤄진다.
    2. 실행 컨텍스트를 생성하고, 변수와 함수를 등록한다. (즉, 컴퓨터에 내가 쓴 변수와 함수의 존재를 알리는 역할을 하는 과정임)
2. 초기화 단계
    1. 선언 키워드를 통해 이름이 정해진 변수에 값을 저장하기 위해 **메모리 공간을 확보**하고, [var만 해당]암묵적으로 `undefined` 를 할당한다.
3. 할당 단계
    1. [let, const만 해당] 콜 스택 메모리 저장 영역에 메모리를 확보한다.
    2. 해당 메모리 주소값을 기존 `undefined` 가 저장되어 있는 변수에 교체하여 저장한다.
    
<br/>
<br/>

## 호이스팅?

변수의 선언과 초기화를 분리한 후, 선언만 코드의 최상단으로 옮기는 것. 

var로 선언한 변수의 경우, 호이스팅을 하면 `undefined` 로 변수를 초기화한다.

반면, let, const로 선언한 변수의 경우에는 호이스팅 시 변수를 초기화하지 않는다.

주의해야할 점이 있다면, 선언과 초기화를 함께 수행하는 var의 경우, 선언 코드까지 실행해야만 변수가 초기화된 상태가 된다.

<br/>
<br/>

## TDZ(Temporal Dead Zone)란?

일시적 사각지대.

호이스팅이 발생했을 때, 해당 변수 스코프의 시작 지점부터 실제 변수가 선언되기까지의 영역을 말한다.

TDZ에서 변수에 접근하면 에러가 발생한다.

즉, 선언 전에 변수에 접근할 수 없다.

```jsx
white; // ReferenceError: Cannot access 'white' before initialization
const white = '#FFFFFF';

white; // '#FFFFFF'
```

<br/>
<br/>

## 재선언, 재할당, 호이스팅 여부

셋 다 호이스팅이 일어난다. 

하지만 앞서 말했듯이, var는 선언을 하면 초기화가 함께 일어난다. 그래서 선언보다 호출이 먼저 일어나더라도 에러가 발생하지 않고  `undefined`다. 반면 let, const는 호이스팅이 일어나긴 하지만, 선언만 하고 초기화는 일어나지 않는다. 그래서 선언보다 변수 호출이 먼저 일어나면 메모리 공간이 확보되지 않은 상태(메모리 상에 해당 변수의 참조값이 존재하지 않음)이므로 `reference error`가 발생한다. 

또한 var는 전역 혹은 함수 스코프를 가진다. 함수 외부에서 선언하면 전역 스코프가 되고, 함수 내에서 선언하면 함수 스코프가 되어 함수 내에서만 접근할 수 있다. 반면 let, const는 블록 스코프를 가진다.

|  | 호이스팅 | 재선언 | 재할당 | 스코프 |
| --- | --- | --- | --- | --- |
| var | O | O | O | 전역, 함수 스코프 |
| let | O | X | O | 블록 스코프 |
| const | O | X | X | 블록 스코프 |
